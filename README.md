# 스택에 대한 이야기

**스택**, 영어로는 stack. 무엇일까? 경영대에서는 회계학 시간에 FIFO, LIFO (선입선출법, 후입선출법)를 배운다면 컴공 시간에는 자료구조 시간에 FIFO, LIFO를 배우나보다. 오늘 우리가 보게 될 자료구조는 스택. 슬립스택 아니다. 스택이다.

## 선입선출? 후입선출?
 일단 최근 2018 월드컵이 진행되었고, 한국은 독일을 이기는 기염을 토했다. 일부 사람들은 "한국인의 물귀신 특성 앞에서는 독일도 무용지물"이라는 말을 하기도 했다는데, FIFO는 월드컵 주체인 FIFA와는 아무런 상관이 없다. FIFO는 First In First Out, 즉 처음 들어오는 애가 처음으로 나간다는 거다. 반대로 LIFO는 Last In First Out, 즉 나중에 오는 애가 제일 먼저 나간다는 거다. 편의점에서 알바해본 사람은 알 것이다. 삼각김밥을 고객들이 FIFO로 가져갔으면 좋겠지만 꼭 LIFO로 가져가는 사람들이 있다는 것을.

## 스택은 후입선출 형태의 자료구조
우선 자료구조가 무엇인지 궁금할 수 있다. 영어로 data structure이라고도 쓰는 자료구조를 나무위키에서 찾아보면 다음과 같이 정의한다: "...데이터를 구조적으로 표현하는 방식과 이를 구현하는 데 필요한 알고리즘 대해 논하는 기초이론...". 그러니까 자료를 표현하는 방식을 쓰는 것이다. 왜 필요할까? 그냥 삼각김밥을 아무렇게나 세워두면 안되는거냐? 이유는 간단하다. 삼각김밥을 아무렇게나 두고 사장에게 눈가리고 아웅을 하면 뚝배기가 깨지지만 삼각김밥 정렬을 잘해둬서 눈가리고 참치마요 삼각김밥의 위치를 정확히 짚어내면 추가수당을 받을 수 있기 때문이다.
만약 데이터를 저장할 때 (push 기법의 사용) 그놈이 제일 머리(head)쪽에 가게 하고 출력을 하게 될 시 머리쪽부터 순서대로 뽑아낸다고 규칙을 저장한다면 삼각김밥이 되었든 치즈볶이가 되었든 저장 순서만 알고서도 정확히 원하는 제품의 위치나 순서를 인덱싱하기 쉬울 것이다. 출력은 한번 하고 제거하는 pop 방식이 있다.
이런 형태의 데이터 구조를 바로 스택이라고 부르며, 후입선출 형태를 지닌다고 하는 것이다.

## 구현방법 1: 배열 (Array)의 사용
일단 구현방법이 총 2가지라는 걸 미리 말해뒀어야 했지만 이미 1번 설명을 시작했으므로 일단 배열 설명부터 해본다.
간단히 말해, 배열은 미리 방 크기를 잡아둔다. 마치 엠티를 우리가 갈 때 30명이 갈 거 같으면 방을 30명짜리를 잡듯이 말이다. 30명짜리를 잡고 미리 30명이 각자 앉을 자리를 바닥에 번호로 표시해두면 특정 사람을 뽑아내기 쉬울 것이다. 예를 들어 "거기 상우 왼쪽에 있는 한결이의 뒤쪽에 있는 .. 있는 사람"이라고 부르는 것과 "14번 위치의 희햄!" 이라고 부를 때 무엇이 빠른가? 뒤쪽이 빠르다는 점은 북한 동무들도 린정하며 끄덕이는 바일 것이다.
우리는 엠티에서도 통수충을 조심해야 하는데, 배열 또한 미리 방을 잡아놓기 때문에 통수충이 생기더라도 30명짜리 방을 예약한 상태로 계속 가야한다. 이번 엠티에도 6명이 빠진다고 사전에 통보를 했기에 망정이지 30명 방을 예약했는데 직전에 6명이 빠지게 되었으면 돈을 날리고 운장이가 매우 화가 났을 것이다. 그렇게 되면 누구의 안전도 보장할 수 없게 되었을 것이다.
또한 14번 위치의 희햄이 갑자기 네이버에 뽑혀서 엠티에 불참한다고 한다고 해서 15번부터 30번까지의 모든 친구들을 한칸씩 땡기라고 하는 건 너무 많은 힘을 들게 하니 그냥 희햄 자리를 NULL로 두게 된다. 만약 희햄이 미리 못오겠다고 얘기를 해서 14번 자리를 메꿔놨는데 희햄이 네이버에서 일 별로 안준다고 엠티로 오게 되면 다시 14번 자리를 내줘야 하는데 또 희햄을 끼우려면 기존의 14~29번은 모두 한칸씩 뒤로 옮겨야 한다. 
**요약** 배열은 데이터를 찾는 속도는 우사인 볼트가 영화 보는 내내 소변이 마려워 버티다가 끝나자마자 화장실 가는 속도에 버금가지만 그만큼 기본적으로 차지하는 크기가 크다. 미리 최대한 저장해야 하는 양을 대관해놓지 않으면 데이터가 들어갈 자리가 없어 버퍼 오버플로우가 생기는 문제를 범할 수 있기 때문이다. 데이터의 수정이 조금 복잡해진다.
## 구현방법 2: 연결 리스트 (linked list)의 사용

연결리스트는 릴레이 형태로 자료를 쌓아주게 된다. 배열과는 정반대의 특성을 지니고 있다. 마라톤 하는 것 마냥 데이터와 옆집 주소가 함께 주어진다. 얘를 들어서 A가 건우의 집을 가기 위해서 네이버 지도에 좌표 찍고 가는게 아니라 희햄(또는 head cound 함수)이 A에게 "건우 집은 가장 head에 해당하는 태훈 집에서 4번 옆집으로 가면 될꺼야"라는 지시를 해주면 운장 집 옆의 한결 집 옆의 재호 집 옆의 외질 집 옆의 건우 집으로 가야 한다는 것이다. 장점은 만약 외질과 건우 사이에 흥민이네 집을 추가하고 싶다면 외질 옆집을 흥민이 집으로 바꿔주고 흥민이 옆집을 건우 집으로 둬서 데이터의 끼우기가 용이하다는 것이다. 문제는 건우네 집 가기가 드럽게 어렵다는 것이다. 가뜩이나 굳이 찾아가기 싫은데 찾기도 어려우면 어휴...
**요약** 데이터의 수정은 용이하지만 불러오는 데 시간이 오래 걸린다.

## 용도
인터넷에서 뒤로가기는 대표적인 LIFO 방식이다. 그 외에 일단 찾아본 방식은 재귀함수 호출, 컴퓨터 오퍼레이팅 시스템의 스택, 괄호 문제 등등에서 응용할 수 있다는 것이다. 
웹 브라우저의 뒤로가기, 프로그램에서의 재귀함수 호출, OS의 시스템 스택 등 실제 프로그램들에서도 많이 사용되고, 괄호 짝 맞추기나 전/후위 연산자 문제, 미로 찾기 등의 알고리즘 문제 해결과 이후 더 복잡한 자료구조에서도 스택을 활용하는 경우가 있다.
함수가 지정되기도 한다는데, 나는 이 부분이 재밌게 읽히면서도 잘 이해가 안되서 희햄에게 질문할 예정이다.
"어떤 함수든 호출되는 순간 스택에 그 함수를 위한 영역 (스택 프레임 stack frame) 이 할당된다.."

## 문제풀이 : 백준 10828번
애초에 파이썬에서 사용되는 어레이는 어느 정도 위의 배열과 링크드 리스트의 개념이 합쳐져 있는 느낌이 든다. 왜냐하면 중간의 인자를 빼면 알아서 땡겨지는 면모를 보이기도 하지만 우리가 실제로 입력하고 쓰는 방식은 배열 - [1,2,3,4]와 같은 모습을 보이기 때문이다.

    stack = []
    stack.append(data)
    print(stack.pop())


## 파이썬에서의 라이브러리?
역시 없는 것이 없는 파이썬. 큐 형태로 주어진다. 큐는 분명 다른 자료구조이지만 LIFO라는 말을 붙여줌으로서 스택의 자료구조를 구현하는 듯 하다.
상우의 코드가 가장 깔끔해 보이므로 상우의 것을 참고해서 써본다.

    import queue
    s = queue.LifoQueue()
